<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚»ãƒªãƒ•ã¨åœ°ã®æ–‡åˆ†é›¢ãƒ„ãƒ¼ãƒ«ï¼ˆãƒ•ã‚©ãƒ«ãƒ€å¯¾å¿œï¼‰</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 200px; }
    .output { white-space: pre-wrap; background: #f9f9f9; padding: 10px; margin-top: 10px; }
    button { margin: 5px; }
  </style>
</head>
<body>
  <h2>ã‚»ãƒªãƒ•ã¨åœ°ã®æ–‡åˆ†é›¢ãƒ„ãƒ¼ãƒ«ï¼ˆãƒ•ã‚©ãƒ«ãƒ€å¯¾å¿œï¼‰</h2>

  <input type="file" id="folderInput" webkitdirectory directory multiple>
  <button onclick="processFolder()">ãƒ•ã‚©ãƒ«ãƒ€ã®åˆ†é›¢å‡¦ç†</button>
  <button onclick="downloadZip()" id="zipButton" style="display:none;">åˆ†é›¢çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>

  <div class="output" id="log"></div>

  <div class="btn-group">
        <a href="index.html"><button>æˆ»ã‚‹</button></a>
    </div>


  <script>
    const results = {};
    const zip = new JSZip();

    function splitText(text) {
      const result = [];
      let buffer = '';
      let narrationBuffer = '';
      const stack = [];
      const quotePairs = {'ã€Œ': 'ã€', 'ã€': 'ã€'};
      const openingQuotes = Object.keys(quotePairs);
      const closingQuotes = Object.values(quotePairs);

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (openingQuotes.includes(char)) {
          if (narrationBuffer.trim()) {
            result.push(`[åœ°ã®æ–‡] ${narrationBuffer.trim()}`);
            narrationBuffer = '';
          }
          buffer += char;
          stack.push(quotePairs[char]);
        } else if (closingQuotes.includes(char)) {
          buffer += char;
          if (stack.length && char === stack[stack.length - 1]) {
            stack.pop();
          }
          if (stack.length === 0) {
            result.push(`[ã‚»ãƒªãƒ•] ä¸æ˜ï¼š${buffer.trim()}`);
            buffer = '';
          }
        } else {
          if (stack.length) {
            buffer += char;
          } else {
            narrationBuffer += char;
          }
        }
      }

      if (narrationBuffer.trim()) {
        result.push(`[åœ°ã®æ–‡] ${narrationBuffer.trim()}`);
      }

      return result.join('\n');
    }

    async function processFolder() {
      const input = document.getElementById('folderInput');
      const files = input.files;
      const log = document.getElementById('log');
      log.textContent = '';

      if (!files.length) {
        alert("ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„");
        return;
      }

      zip.files = {}; // reset
      for (const file of files) {
        if (!file.name.endsWith('.txt')) continue;

        const text = await file.text();
        const output = splitText(text);
        const newName = file.name.replace(/\.txt$/, '_separated.txt');
        zip.file(newName, output);
        results[newName] = output;

        log.textContent += `âœ… ${newName} ã‚’å‡¦ç†ã—ã¾ã—ãŸ\n`;
      }

      if (Object.keys(results).length > 0) {
        document.getElementById('zipButton').style.display = 'inline-block';
        log.textContent += `\nğŸ“¦ åˆ†é›¢å®Œäº†ï¼ã€Œåˆ†é›¢çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ãƒœã‚¿ãƒ³ã§ä¿å­˜ã§ãã¾ã™ã€‚`;
      } else {
        log.textContent += `âš ï¸ å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.txtï¼‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`;
      }
    }

    function downloadZip() {
      zip.generateAsync({ type: "blob" })
        .then(blob => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "separated_texts.zip";
          a.click();
        });
    }
  </script>
</body>
</html>
